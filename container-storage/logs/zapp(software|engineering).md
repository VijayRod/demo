```
Software Engineering
│
├── Software Architecture
│   ├── Architectural Patterns
│   │   ├── MVC / MVVM
│   │   ├── Clean Architecture
│   │   ├── Hexagonal / Onion
│   │   └── Event-Driven Architecture ✅
│   └── Application Layers
│       ├── Presentation Layer (UI)
│       ├── Business Logic Layer
│       └── Data Access Layer
│           └── ORM (Entity Framework, Dapper, NHibernate, ADO.NET)

├── Frontend Technologies
│   ├── React / Next.js
│   ├── Tailwind CSS
│   ├── Zustand / Redux Toolkit
│   └── WebSockets / Socket.IO

├── Backend Technologies
│   ├── Node.js / NestJS
│   ├── Go (High Performance)
│   ├── ASP.NET Core / C#
│   ├── REST / GraphQL
│   └── Messaging (Kafka, NATS, Redis PubSub)

├── Infrastructure & Observability
│   ├── Kubernetes (AKS)
│   ├── Autoscaling (KEDA / HPA / VPA)
│   ├── GitOps (ArgoCD / Flux)
│   ├── Terraform / Helm Charts
│   └── Observability
│       ├── Prometheus (metrics collection) ✅
│       ├── Grafana (dashboards & alerts) ✅
│       ├── eBPF (kernel-level observability) ✅
│       │   ├── Cilium / Tetragon / BCC / BPFTrace
│       │   └── Falco (runtime threat detection)
│       ├── Loki / Alertmanager
│       ├── OpenTelemetry (unified tracing)
│       ├── Distributed Profiling (Parca, Pyroscope)
│       └── Linux OOM Killer
│           ├── dmesg / kernel logs
│           ├── oom_score_adj tuning
│           └── K8s Memory Evictions / Limits

├── Software Design
│   ├── Design Patterns
│   │   ├── Creational (Factory, Singleton, Builder)
│   │   ├── Structural (Adapter, Decorator, Composite)
│   │   └── Behavioral (Strategy, Observer, Command)
│   └── SOLID Principles / OOP

├── Quality & Maintainability
│   ├── Testing (Unit, Integration)
│   │   ├── xUnit / NUnit
│   │   └── Moq
│   ├── Refactoring
│   └── Code Reviews / Linting / Static Analysis
│       ├── StyleCop
│       ├── SonarQube
│       └── ReSharper

├── Software Lifecycle & Process
│   ├── CI/CD (Continuous Integration / Delivery)
│   ├── DevOps Practices
│   ├── Documentation & Modeling (UML, Diagrams)
│   └── Twelve-Factor App Principles ✅

├── Core Technologies
│   ├── Data Persistence
│   │   ├── SQL Server / NoSQL / Schema Design
│   │   ├── Indexing / Query Plans / Caching
│   │   ├── Search Structures (Full-text, Trie)
│   │   ├── ACID Transactions ✅
│   │   ├── Write-Ahead Logging (WAL) ✅
│   │   └── Replication (Leader-Follower, Multi-Leader, Geo) ✅
│   ├── API & Testing Tools
│   │   ├── REST / JWT / OAuth2
│   │   ├── Swagger / Postman / Fiddler
│   │   └── Contract Testing (Pact, Dredd)
│   ├── Code Quality & Version Control
│   │   ├── GitHub / GitLab / Azure Repos
│   │   ├── Git Flow / Trunk-Based Development
│   │   └── Commit Signing (GPG / SSH)
│   └── Reporting & Analytics
│       ├── Grafana Panels / Power BI
│       ├── SQL Reporting / ETL / SSRS
│       └── KPIs / SLAs / SLOs

├── AI/ML & Intelligent Automation
│   ├── LLMs (OpenAI GPT, LLaMA, Mistral)
│   ├── MLOps (MLFlow, Kubeflow, Azure ML)
│   ├── Inference (ONNX, TensorRT)
│   ├── Feature Stores (Feast)
│   └── Vector Embeddings & Semantic Search

├── Edge Computing & Serverless
│   ├── Cloudflare Workers / Vercel Edge Functions
│   ├── AWS Lambda / Azure Functions
│   ├── WebAssembly (WASM)
│   └── Lightweight Runtimes (Spin, Slang)

├── Data Streaming & Realtime Systems
│   ├── Apache Flink / Spark Streaming
│   ├── Apache Pinot / Druid
│   ├── Change Data Capture (Debezium + Kafka)
│   └── Temporal.io / Cadence (Workflow Orchestration)

├── Distributed Systems ✅
│   ├── Principles
│   │   ├── CAP Theorem / PACELC
│   │   ├── Consistency Models (Strong, Eventual, Causal)
│   │   ├── Replication (Sync, Async, Geo, Quorum) ✅
│   │   ├── ACID / WAL ✅
│   │   └── Split-Brain Handling

```
